-- File: wb_lcd.vhd
-- Generated by MyHDL 0.6
-- Date: Mon Apr 20 03:13:35 2009


package pck_wb_lcd is

    type t_enum_t_TxState_2 is (
    tx_high_setup,
    tx_high_hold,
    tx_oneus,
    tx_low_setup,
    tx_low_hold,
    tx_fortyus,
    tx_done
);
    type t_enum_t_State_1 is (
    display_init,
    init_fifteenms,
    init_one,
    init_two,
    init_three,
    init_four,
    init_five,
    init_six,
    init_seven,
    init_eight,
    display_function_set,
    display_entry_set,
    display_set_display,
    display_clr_display,
    display_pause_setup,
    display_pause,
    display_done,
    display_set_addr,
    display_char_write
);

end package pck_wb_lcd;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_06.all;

use work.pck_wb_lcd.all;

entity wb_lcd is
    port (
        wb_clk_i: in std_logic;
        wb_rst_i: in std_logic;
        wb_dat_i: in unsigned(31 downto 0);
        wb_dat_o: out unsigned(31 downto 0);
        wb_adr_i: in unsigned(31 downto 0);
        wb_sel_i: in unsigned(3 downto 0);
        wb_we_i: in std_logic;
        wb_cyc_i: in std_logic;
        wb_stb_i: in std_logic;
        wb_ack_o: out std_logic;
        SF_D: out unsigned(3 downto 0);
        LCD_E: out std_logic;
        LCD_RS: out std_logic;
        LCD_RW: out std_logic
    );
end entity wb_lcd;

architecture MyHDL of wb_lcd is

signal busy: std_logic;
signal lcd_we: std_logic;
signal mylcd_tx_init: std_logic;
signal mylcd_delay_load: std_logic;
signal mylcd_tx_done: std_logic;
signal mylcd_SF_D1: unsigned(3 downto 0);
signal mylcd_SF_D0: unsigned(3 downto 0);
signal mylcd_LCD_E1: std_logic;
signal mylcd_LCD_E0: std_logic;
signal mylcd_delay_done: std_logic;
signal mylcd_tx_byte: unsigned(7 downto 0);
signal mylcd_wr_addr: unsigned(6 downto 0);
signal mylcd_output_selector: std_logic;
signal mylcd_state: t_enum_t_State_1;
signal mylcd_tx_delay_value: unsigned(19 downto 0);
signal mylcd_main_delay_value: unsigned(19 downto 0);
signal mylcd_tx_delay_load: std_logic;
signal mylcd_delay_value: unsigned(19 downto 0);
signal mylcd_wr_dat: unsigned(6 downto 0);
signal mylcd_main_delay_load: std_logic;
signal mylcd_tx_state: t_enum_t_TxState_2;
signal mylcd_counter_counter: unsigned(20 downto 0);

begin


WB_LCD_WISHBONE_LOGIC: process (busy, wb_we_i, wb_stb_i, wb_cyc_i, wb_adr_i) is
begin
    wb_ack_o <= (wb_cyc_i and wb_stb_i);
    
    lcd_we <= (wb_cyc_i and wb_stb_i and wb_we_i and to_std_logic(wb_adr_i /= 128));
    if to_boolean(busy) then
        wb_dat_o <= "00000000000000000000000000000001";
    else
        wb_dat_o <= "00000000000000000000000000000000";
    end if;
end process WB_LCD_WISHBONE_LOGIC;


mylcd_output_selector <= ((mylcd_state = display_init) or (mylcd_state = init_fifteenms) or (mylcd_state = init_one) or (mylcd_state = init_two) or (mylcd_state = init_three) or (mylcd_state = init_four) or (mylcd_state = init_five) or (mylcd_state = init_six) or (mylcd_state = init_seven) or (mylcd_state = init_eight));

WB_LCD_MYLCD_CONUNTER_SHARING_VALUE: process (mylcd_main_delay_value, mylcd_tx_delay_load, mylcd_tx_delay_value) is
begin
    if to_boolean(mylcd_tx_delay_load) then
        mylcd_delay_value <= mylcd_tx_delay_value;
    else
        mylcd_delay_value <= mylcd_main_delay_value;
    end if;
end process WB_LCD_MYLCD_CONUNTER_SHARING_VALUE;

WB_LCD_MYLCD_DISPLAYFSM: process (wb_clk_i, wb_rst_i) is
begin
    if (wb_rst_i = '1') then
        mylcd_state <= display_init;
        mylcd_main_delay_load <= '0';
        mylcd_main_delay_value <= "00000000000000000000";
        mylcd_SF_D1 <= "0000";
        mylcd_LCD_E1 <= '0';
        mylcd_tx_byte <= "00000000";
    elsif rising_edge(wb_clk_i) then
        mylcd_main_delay_load <= '0';
        
        mylcd_main_delay_value <= "00000000000000000000";
        
        case mylcd_state is
            when display_init =>
                mylcd_tx_byte <= "00000000";
                mylcd_state <= init_fifteenms;
                mylcd_main_delay_load <= '1';
                mylcd_main_delay_value <= "10110111000110110000";
            when init_fifteenms =>
                mylcd_main_delay_load <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= init_one;
                    
                    mylcd_main_delay_load <= '1';
                    mylcd_main_delay_value <= "00000000000000001011";
                end if;
            when init_one =>
                mylcd_main_delay_load <= '0';
                mylcd_SF_D1 <= "0011";
                mylcd_LCD_E1 <= '1';
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= init_two;
                    
                    mylcd_main_delay_load <= '1';
                    mylcd_main_delay_value <= "00110010000011001000";
                end if;
            when init_two =>
                mylcd_main_delay_load <= '0';
                mylcd_LCD_E1 <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= init_three;
                    
                    mylcd_main_delay_load <= '1';
                    mylcd_main_delay_value <= "00000000000000001011";
                end if;
            when init_three =>
                mylcd_main_delay_load <= '0';
                mylcd_SF_D1 <= "0011";
                mylcd_LCD_E1 <= '1';
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= init_four;
                    
                    mylcd_main_delay_load <= '1';
                    mylcd_main_delay_value <= "00000001001110001000";
                end if;
            when init_four =>
                mylcd_main_delay_load <= '0';
                mylcd_LCD_E1 <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= init_five;
                    
                    mylcd_main_delay_load <= '1';
                    mylcd_main_delay_value <= "00000000000000001011";
                end if;
            when init_five =>
                mylcd_main_delay_load <= '0';
                mylcd_SF_D1 <= "0011";
                mylcd_LCD_E1 <= '1';
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= init_six;
                    
                    mylcd_main_delay_load <= '1';
                    mylcd_main_delay_value <= "00000000011111010000";
                end if;
            when init_six =>
                mylcd_main_delay_load <= '0';
                mylcd_LCD_E1 <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= init_seven;
                    
                    mylcd_main_delay_load <= '1';
                    mylcd_main_delay_value <= "00000000000000001011";
                end if;
            when init_seven =>
                mylcd_main_delay_load <= '0';
                mylcd_SF_D1 <= "0010";
                mylcd_LCD_E1 <= '1';
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= init_eight;
                    
                    mylcd_main_delay_load <= '1';
                    mylcd_main_delay_value <= "00000000011111010000";
                end if;
            when init_eight =>
                mylcd_main_delay_load <= '0';
                mylcd_LCD_E1 <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= display_function_set;
                    
                end if;
            when display_function_set =>
                mylcd_tx_byte <= "00101000";
                if to_boolean(mylcd_tx_done) then
                    mylcd_state <= display_entry_set;
                end if;
            when display_entry_set =>
                mylcd_tx_byte <= "00000110";
                if to_boolean(mylcd_tx_done) then
                    mylcd_state <= display_set_display;
                end if;
            when display_set_display =>
                mylcd_tx_byte <= "00001100";
                if to_boolean(mylcd_tx_done) then
                    mylcd_state <= display_clr_display;
                end if;
            when display_clr_display =>
                mylcd_tx_byte <= "00000001";
                if to_boolean(mylcd_tx_done) then
                    mylcd_state <= display_pause;
                    mylcd_main_delay_load <= '1';
                    mylcd_main_delay_value <= "00010100000001010000";
                end if;
            when display_pause_setup =>
                mylcd_state <= display_pause;
            when display_pause =>
                mylcd_tx_byte <= "00000000";
                if to_boolean(mylcd_delay_done) then
                    mylcd_state <= display_done;
                    
                end if;
            when display_done =>
                mylcd_tx_byte <= "00000000";
                if to_boolean(lcd_we) then
                    mylcd_state <= display_set_addr;
                    mylcd_wr_addr <= resize(wb_adr_i, 7);
                    mylcd_wr_dat <= resize(wb_dat_i, 7);
                else
                    mylcd_state <= display_done;
                end if;
            when display_set_addr =>
                mylcd_tx_byte <= ("10000000" or mylcd_wr_addr);
                if to_boolean(mylcd_tx_done) then
                    mylcd_state <= display_char_write;
                end if;
            when display_char_write =>
                mylcd_tx_byte <= resize(mylcd_wr_dat, 8);
                if to_boolean(mylcd_tx_done) then
                    mylcd_state <= display_done;
                    
                end if;
        end case;
    end if;
end process WB_LCD_MYLCD_DISPLAYFSM;

WB_LCD_MYLCD_TXFSM: process (wb_clk_i, wb_rst_i) is
begin
    if (wb_rst_i = '1') then
        mylcd_tx_state <= tx_done;
        mylcd_SF_D0 <= "0000";
        mylcd_LCD_E0 <= '0';
    elsif rising_edge(wb_clk_i) then
        mylcd_tx_delay_load <= '0';
        
        mylcd_tx_delay_value <= "00000000000000000000";
        
        case mylcd_tx_state is
            when tx_high_setup =>
                mylcd_LCD_E0 <= '0';
                mylcd_SF_D0 <= mylcd_tx_byte(8-1 downto 4);
                mylcd_tx_delay_load <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_tx_state <= tx_high_hold;
                    mylcd_tx_delay_load <= '1';
                    mylcd_tx_delay_value <= "00000000000000001100";
                end if;
            when tx_high_hold =>
                mylcd_LCD_E0 <= '1';
                mylcd_SF_D0 <= mylcd_tx_byte(8-1 downto 4);
                mylcd_tx_delay_load <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_tx_state <= tx_oneus;
                    mylcd_tx_delay_load <= '1';
                    mylcd_tx_delay_value <= "00000000000000110010";
                end if;
            when tx_oneus =>
                mylcd_LCD_E0 <= '0';
                mylcd_tx_delay_load <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_tx_state <= tx_low_setup;
                    mylcd_tx_delay_load <= '1';
                    mylcd_tx_delay_value <= "00000000000000000010";
                end if;
            when tx_low_setup =>
                mylcd_LCD_E0 <= '0';
                mylcd_SF_D0 <= mylcd_tx_byte(4-1 downto 0);
                mylcd_tx_delay_load <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_tx_state <= tx_low_hold;
                    mylcd_tx_delay_load <= '1';
                    mylcd_tx_delay_value <= "00000000000000001100";
                end if;
            when tx_low_hold =>
                mylcd_LCD_E0 <= '1';
                mylcd_SF_D0 <= mylcd_tx_byte(4-1 downto 0);
                mylcd_tx_delay_load <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_tx_state <= tx_fortyus;
                    mylcd_tx_delay_load <= '1';
                    mylcd_tx_delay_value <= "00000000011111010000";
                end if;
            when tx_fortyus =>
                mylcd_LCD_E0 <= '0';
                mylcd_tx_delay_load <= '0';
                if to_boolean(mylcd_delay_done) then
                    mylcd_tx_state <= tx_done;
                    mylcd_tx_done <= '1';
                end if;
            when tx_done =>
                mylcd_LCD_E0 <= '0';
                mylcd_tx_done <= '0';
                mylcd_tx_delay_load <= '0';
                if to_boolean(mylcd_tx_init) then
                    mylcd_tx_state <= tx_high_setup;
                    mylcd_tx_delay_load <= '1';
                    mylcd_tx_delay_value <= "00000000000000000010";
                end if;
        end case;
    end if;
end process WB_LCD_MYLCD_TXFSM;


mylcd_delay_load <= to_std_logic(to_boolean(mylcd_tx_delay_load) or to_boolean(mylcd_main_delay_load));


busy <= to_std_logic(mylcd_state /= display_done);
LCD_RW <= '0';

WB_LCD_MYLCD_OUTPUT_TX_OR_INIT_MUX: process (mylcd_SF_D1, mylcd_SF_D0, mylcd_LCD_E1, mylcd_LCD_E0, mylcd_output_selector) is
begin
    if to_boolean(mylcd_output_selector) then
        SF_D <= mylcd_SF_D1;
        LCD_E <= mylcd_LCD_E1;
    else
        SF_D <= mylcd_SF_D0;
        LCD_E <= mylcd_LCD_E0;
    end if;
end process WB_LCD_MYLCD_OUTPUT_TX_OR_INIT_MUX;


mylcd_tx_init <= ((not mylcd_tx_done) and ((mylcd_state = display_function_set) or (mylcd_state = display_entry_set) or (mylcd_state = display_set_display) or (mylcd_state = display_clr_display) or (mylcd_state = display_set_addr) or (mylcd_state = display_char_write)));
LCD_RS <= (not ((mylcd_state = display_function_set) or (mylcd_state = display_entry_set) or (mylcd_state = display_set_display) or (mylcd_state = display_clr_display) or (mylcd_state = display_set_addr)));


mylcd_delay_done <= to_std_logic(mylcd_counter_counter = 0);

WB_LCD_MYLCD_COUNTER_COUNTDOWN_LOGIC: process (wb_clk_i) is
begin
    if rising_edge(wb_clk_i) then
        if to_boolean(mylcd_delay_load) then
            mylcd_counter_counter <= resize(mylcd_delay_value, 21);
        else
            mylcd_counter_counter <= (mylcd_counter_counter - 1);
        end if;
    end if;
end process WB_LCD_MYLCD_COUNTER_COUNTDOWN_LOGIC;

end architecture MyHDL;
