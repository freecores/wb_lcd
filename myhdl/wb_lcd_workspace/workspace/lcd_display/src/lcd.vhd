-- File: lcd.vhd
-- Generated by MyHDL 0.6
-- Date: Wed Apr 15 16:54:27 2009


package pck_lcd is

    type t_enum_t_TxState_2 is (
    tx_high_setup,
    tx_high_hold,
    tx_oneus,
    tx_low_setup,
    tx_low_hold,
    tx_fortyus,
    tx_done
);
    type t_enum_t_State_1 is (
    display_init,
    init_fifteenms,
    init_one,
    init_two,
    init_three,
    init_four,
    init_five,
    init_six,
    init_seven,
    init_eight,
    display_function_set,
    display_entry_set,
    display_set_display,
    display_clr_display,
    display_pause_setup,
    display_pause,
    display_set_addr1,
    display_char_write1,
    display_set_addr2,
    display_char_write2,
    display_done
);

end package pck_lcd;

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;
use std.textio.all;

use work.pck_myhdl_06.all;

use work.pck_lcd.all;

entity lcd is
    port (
        clk: in std_logic;
        reset: in std_logic;
        dat: in unsigned(31 downto 0);
        addr: in unsigned(6 downto 0);
        we: in std_logic;
        repaint: in std_logic;
        busy: out std_logic;
        SF_D: out unsigned(3 downto 0);
        LCD_E: out std_logic;
        LCD_RS: out std_logic;
        LCD_RW: out std_logic
    );
end entity lcd;

architecture MyHDL of lcd is

signal tx_init: std_logic;
signal pos: unsigned(8 downto 0);
signal delay_load: std_logic;
signal tx_done: std_logic;
signal SF_D1: unsigned(3 downto 0);
signal SF_D0: unsigned(3 downto 0);
signal LCD_E1: std_logic;
signal LCD_E0: std_logic;
signal delay_done: std_logic;
signal tx_byte: unsigned(7 downto 0);
signal output_selector: std_logic;
signal state: t_enum_t_State_1;
signal tx_delay_value: unsigned(19 downto 0);
signal main_delay_value: unsigned(19 downto 0);
signal tx_delay_load: std_logic;
signal delay_value: unsigned(19 downto 0);
signal main_delay_load: std_logic;
signal tx_state: t_enum_t_TxState_2;
signal counter_counter: unsigned(20 downto 0);
type t_array_ram is array(0 to 80-1) of unsigned(7 downto 0);
signal ram: t_array_ram;

begin



output_selector <= ((state = display_init) or (state = init_fifteenms) or (state = init_one) or (state = init_two) or (state = init_three) or (state = init_four) or (state = init_five) or (state = init_six) or (state = init_seven) or (state = init_eight));

LCD_CONUNTER_SHARING_VALUE: process (main_delay_value, tx_delay_load, tx_delay_value) is
begin
    if to_boolean(tx_delay_load) then
        delay_value <= tx_delay_value;
    else
        delay_value <= main_delay_value;
    end if;
end process LCD_CONUNTER_SHARING_VALUE;

LCD_TXFSM: process (clk, reset) is
begin
    if (reset = '1') then
        tx_state <= tx_done;
        SF_D0 <= "0000";
        LCD_E0 <= '0';
    elsif rising_edge(clk) then
        tx_delay_load <= '0';
        
        tx_delay_value <= "00000000000000000000";
        
        case tx_state is
            when tx_high_setup =>
                LCD_E0 <= '0';
                SF_D0 <= tx_byte(8-1 downto 4);
                tx_delay_load <= '0';
                if to_boolean(delay_done) then
                    tx_state <= tx_high_hold;
                    tx_delay_load <= '1';
                    tx_delay_value <= "00000000000000001100";
                end if;
            when tx_high_hold =>
                LCD_E0 <= '1';
                SF_D0 <= tx_byte(8-1 downto 4);
                tx_delay_load <= '0';
                if to_boolean(delay_done) then
                    tx_state <= tx_oneus;
                    tx_delay_load <= '1';
                    tx_delay_value <= "00000000000000110010";
                end if;
            when tx_oneus =>
                LCD_E0 <= '0';
                tx_delay_load <= '0';
                if to_boolean(delay_done) then
                    tx_state <= tx_low_setup;
                    tx_delay_load <= '1';
                    tx_delay_value <= "00000000000000000010";
                end if;
            when tx_low_setup =>
                LCD_E0 <= '0';
                SF_D0 <= tx_byte(4-1 downto 0);
                tx_delay_load <= '0';
                if to_boolean(delay_done) then
                    tx_state <= tx_low_hold;
                    tx_delay_load <= '1';
                    tx_delay_value <= "00000000000000001100";
                end if;
            when tx_low_hold =>
                LCD_E0 <= '1';
                SF_D0 <= tx_byte(4-1 downto 0);
                tx_delay_load <= '0';
                if to_boolean(delay_done) then
                    tx_state <= tx_fortyus;
                    tx_delay_load <= '1';
                    tx_delay_value <= "00000000011111010000";
                end if;
            when tx_fortyus =>
                LCD_E0 <= '0';
                tx_delay_load <= '0';
                if to_boolean(delay_done) then
                    tx_state <= tx_done;
                    tx_done <= '1';
                end if;
            when tx_done =>
                LCD_E0 <= '0';
                tx_done <= '0';
                tx_delay_load <= '0';
                if to_boolean(tx_init) then
                    tx_state <= tx_high_setup;
                    tx_delay_load <= '1';
                    tx_delay_value <= "00000000000000000010";
                end if;
        end case;
    end if;
end process LCD_TXFSM;


delay_load <= to_std_logic(to_boolean(tx_delay_load) or to_boolean(main_delay_load));


busy <= to_std_logic(state /= display_done);
LCD_RW <= '0';

LCD_OUTPUT_TX_OR_INIT_MUX: process (SF_D1, SF_D0, LCD_E1, LCD_E0, output_selector) is
begin
    if to_boolean(output_selector) then
        SF_D <= SF_D1;
        LCD_E <= LCD_E1;
    else
        SF_D <= SF_D0;
        LCD_E <= LCD_E0;
    end if;
end process LCD_OUTPUT_TX_OR_INIT_MUX;

LCD_MEMWRITE: process (clk) is
begin
    if rising_edge(clk) then
        if to_boolean(we) then
            ram(to_integer(addr)) <= resize(dat, 8);
        end if;
    end if;
end process LCD_MEMWRITE;

LCD_DISPLAYFSM: process (clk, reset) is
begin
    if (reset = '1') then
        state <= display_init;
        main_delay_load <= '0';
        main_delay_value <= "00000000000000000000";
        SF_D1 <= "0000";
        LCD_E1 <= '0';
        tx_byte <= "00000000";
        pos <= "000000000";
    elsif rising_edge(clk) then
        main_delay_load <= '0';
        
        main_delay_value <= "00000000000000000000";
        
        case state is
            when display_init =>
                tx_byte <= "00000000";
                state <= init_fifteenms;
                main_delay_load <= '1';
                main_delay_value <= "10110111000110110000";
            when init_fifteenms =>
                main_delay_load <= '0';
                if to_boolean(delay_done) then
                    state <= init_one;
                    
                    main_delay_load <= '1';
                    main_delay_value <= "00000000000000001011";
                end if;
            when init_one =>
                main_delay_load <= '0';
                SF_D1 <= "0011";
                LCD_E1 <= '1';
                if to_boolean(delay_done) then
                    state <= init_two;
                    
                    main_delay_load <= '1';
                    main_delay_value <= "00110010000011001000";
                end if;
            when init_two =>
                main_delay_load <= '0';
                LCD_E1 <= '0';
                if to_boolean(delay_done) then
                    state <= init_three;
                    
                    main_delay_load <= '1';
                    main_delay_value <= "00000000000000001011";
                end if;
            when init_three =>
                main_delay_load <= '0';
                SF_D1 <= "0011";
                LCD_E1 <= '1';
                if to_boolean(delay_done) then
                    state <= init_four;
                    
                    main_delay_load <= '1';
                    main_delay_value <= "00000001001110001000";
                end if;
            when init_four =>
                main_delay_load <= '0';
                LCD_E1 <= '0';
                if to_boolean(delay_done) then
                    state <= init_five;
                    
                    main_delay_load <= '1';
                    main_delay_value <= "00000000000000001011";
                end if;
            when init_five =>
                main_delay_load <= '0';
                SF_D1 <= "0011";
                LCD_E1 <= '1';
                if to_boolean(delay_done) then
                    state <= init_six;
                    
                    main_delay_load <= '1';
                    main_delay_value <= "00000000011111010000";
                end if;
            when init_six =>
                main_delay_load <= '0';
                LCD_E1 <= '0';
                if to_boolean(delay_done) then
                    state <= init_seven;
                    
                    main_delay_load <= '1';
                    main_delay_value <= "00000000000000001011";
                end if;
            when init_seven =>
                main_delay_load <= '0';
                SF_D1 <= "0010";
                LCD_E1 <= '1';
                if to_boolean(delay_done) then
                    state <= init_eight;
                    
                    main_delay_load <= '1';
                    main_delay_value <= "00000000011111010000";
                end if;
            when init_eight =>
                main_delay_load <= '0';
                LCD_E1 <= '0';
                if to_boolean(delay_done) then
                    state <= display_function_set;
                    
                end if;
            when display_function_set =>
                tx_byte <= "00101000";
                if to_boolean(tx_done) then
                    state <= display_entry_set;
                end if;
            when display_entry_set =>
                tx_byte <= "00000110";
                if to_boolean(tx_done) then
                    state <= display_set_display;
                end if;
            when display_set_display =>
                tx_byte <= "00001100";
                if to_boolean(tx_done) then
                    state <= display_clr_display;
                end if;
            when display_clr_display =>
                tx_byte <= "00000001";
                if to_boolean(tx_done) then
                    state <= display_pause_setup;
                    main_delay_load <= '1';
                    main_delay_value <= "00010100000001010000";
                end if;
            when display_pause_setup =>
                state <= display_pause;
            when display_pause =>
                tx_byte <= "00000000";
                if to_boolean(delay_done) then
                    state <= display_set_addr1;
                    
                end if;
            when display_set_addr1 =>
                tx_byte <= "10000000";
                if to_boolean(tx_done) then
                    state <= display_char_write1;
                    pos <= "000000000";
                end if;
            when display_char_write1 =>
                tx_byte <= ram(pos);
                if to_boolean(tx_done) then
                    if (pos = 15) then
                        state <= display_set_addr2;
                        
                    else
                        pos <= (pos + 1);
                    end if;
                end if;
            when display_set_addr2 =>
                tx_byte <= "11000000";
                if to_boolean(tx_done) then
                    state <= display_char_write2;
                    pos <= "001000000";
                end if;
            when display_char_write2 =>
                tx_byte <= ram(pos);
                if to_boolean(tx_done) then
                    if (pos = 79) then
                        state <= display_done;
                        
                    else
                        pos <= (pos + 1);
                    end if;
                end if;
            when display_done =>
                tx_byte <= "00000000";
                if to_boolean(repaint) then
                    state <= display_function_set;
                else
                    state <= display_done;
                end if;
        end case;
    end if;
end process LCD_DISPLAYFSM;


delay_done <= to_std_logic(counter_counter = 0);

LCD_COUNTER_COUNTDOWN_LOGIC: process (clk) is
begin
    if rising_edge(clk) then
        if to_boolean(delay_load) then
            counter_counter <= resize(delay_value, 21);
        else
            counter_counter <= (counter_counter - 1);
        end if;
    end if;
end process LCD_COUNTER_COUNTDOWN_LOGIC;


tx_init <= ((not tx_done) and ((state = display_function_set) or (state = display_entry_set) or (state = display_set_display) or (state = display_clr_display) or (state = display_set_addr1) or (state = display_char_write1) or (state = display_set_addr2) or (state = display_char_write2)));
LCD_RS <= (not ((state = display_function_set) or (state = display_entry_set) or (state = display_set_display) or (state = display_clr_display) or (state = display_set_addr1) or (state = display_set_addr2)));

end architecture MyHDL;
